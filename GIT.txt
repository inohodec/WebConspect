GIT и PowerShell в Windows 10.
1 запускаем PowerShell от админа
2 клонируем git clone https://github.com/dahlbyk/posh-git в подготовленную папку
3 переходим в корень скачанного репозитория и в PowerShell выполняем  Set-ExecutionPolicy RemoteSigned
4 Проверяем на всяк случай Get-ExecutionPolicy
5 далее .\install.ps1
6 После этого склонированную папку не удаляем, не перемещаем

git config --global user.name "Max Ostepan from LINUX Mint"    //Устанавливаем глобально имя пользователя 
git config --global user.email mail.me@to.linux                //Устанавливаем глобально почту
git config --list                                              //Показывает список настроек 
git config --unset-all --global user.email                     //Удалить какую либо настройку
sudo git init                                                  //Создаем репозиторий(до этого нужно перейти в консоли в нужную папку) 
git status                                                     //Показывает статус файлов в директории
git add index.php                                              //Добавляет файл index.php под версионныйкогтроль
git status -s                                                  //короткая форма отображения 
git diff                                                       //Показывает разницу в файлах с последним коммитом и файлом вне индекса
git diff --stage                                               //Показывает разницу в файлах под индексом и последним коммитом кот будет записана в коммит
git commit                                                     //Добавляет подготовленные файлы в репозиторий(открывая редактор для внесения комментария)
git log                                                        //История коммитов(фиксаций)
git log -p                                                     //выводит лог с полным диффом
git log --pretty=oneline                                       //выведет коммиты в одну строку 
git log --pretty=oneline -3                                    //выведет последние 3 коммита в одну строку 
git log --pretty=oneline --all                                 //выведет все коммиты в одну строку 
git log --pretty=oneline --author="Max Ostepan"                //выведет коммиты автора "Max Ostepan" 


git show [commit's_id]                                         //показывает все изменения по данному коммиту
                                                               //без хэша коммита показывает инфо о текущем

git blame [file_name]                                          //показывает кто и когда совершал коммиты по файлу и что в нем менял
git grep -i [keyword]                                          //ищет совпадение по ключевой фразе в файлах которые под гитом
поиск по журналу и т.д. по ссылке ниже 
https://git-scm.com/book/ru/v2/%D0%98%D0%BD%D1%81%D1%82%D1%80%D1%83%D0%BC%D0%B5%D0%BD%D1%82%D1%8B-Git-%D0%9F%D0%BE%D0%B8%D1%81%D0%BA

git commit -m "Some review"                                    //Совершает коммит с добавлением комментария без открытия редактора
git add .                                                      //Подготавливает все файлы для коммита(состояние staged)
git rm                                                         
git commit -a -m "Commit whithout add"                         //Делает коммит всех файлов которые отслеживаются миную add

git clean -fd                                                  //удаляет неотслеживаемые файлы -f – force, -d – directory
git restore --staged [file]                                    //убирает файл из stage области с сохранением изменений в нем
git restore [file]                                             //восттанавливает содержимое файла, вне индекса, беря данные из последнего коммита

git commit --amend -m "Small modifying of Ver3.0"              //Изменение последнего коммита, без создания нового коммита.
                                                                 Если в файле(лах) небыло изменений то можно таким способом сменить комментарий
git commit --amend --no-edit                                   //Изменяет последний коммит без правки комментария(оставляет существующий)
git reset HEAD new.txt                                         //Удаляет файл new.txt из staged области

git checkout [id_commit]                                       //загружает в рабочую директорию данные указанного коммита
git switch -                                                   //возвращение к последнему коммиту в текущей ветке
git checkout new.txt                                           //Отменяет изменения до состояния последнего коммита
                                                                
отменяем изменения
***************************************************************************************************************
git revert [commit's_id]                    //возвращает состояние на момент указанного коммита и выводит измененные файл(ы) из стайдж области и указывает, что было изменено
ПРИМЕР ВЫВОДА:
на текущий момент
<?php
const ONE = 'one;'                            
const TWO = 'two;'
const THREE = 'three;'

ПОСЛЕ git revert
<?php
const ONE = 'one;'
<<<<<<< HEAD                              
const TWO = 'two;'
const THREE = 'three;'
=======
>>>>>>> parent of c40a4af (add two)

Если коммит был отправлен во внешний репозиторий, например, на Github, то менять историю ни в коем случае нельзя, это сломает работу у тех, кто работает с вами над проектом.
git reset [id_or_HEAD] new.txt              //удаляем из stage
git checkout new.txt                        //Возвращает состояние файла на момент последнего коммита 
***************************************************************************************************************
git revert HEAD --no-edit                                      //возвращает состояние текущего коммита, до состояния 
                                                               //предыдущего(не удаляя онный) или указаного через //хеш, помечается как reverted
                                                                       
//================================================= BRANCHES ==================================================

git branch payment-feature                                     //создает ветку payment-feature
git branch                                                     //список веток
git branch -v                                                  //расширенный вид списока веток
git checkout payment-feature                                   //смена ветки
git branch -d hotfix                                           //удаляет ветку если она уже не нужна 

меняем ветку только если сделали коммит(когда работа завершена) или помещаем изменения в буфер
git stash                                                      //перемещение данных в буфер 
git stash list                                                 //Просмотр буфера 

git stash pop                                                   //Подымает файлы из буфера в тукущую ветку!!!(с меткой HEAD) 
                                                                так что перходим в нужную заранее

git merge                                                       //слияние двух веток
git merge abort                                                 //отмена слияния при возникновении ошибки

git checkout -b name                                            // ветка (создать ветку из текущей и переключиться)
git reset --hard                                                //ОПАСНО! отменить все незакоммиченное(удалит полностью)
git reset --hard HEAD~n                                         //ОПАСНО! двигает указатели вершин веток и откатывает на n коммитов(удалив те что после указателя)

git reset --soft HEAD~n                                         //двигает указатели вершин веток не удаляя последующие(например для слияния коммитов)
git commit -c ORIG_HEAD                                         //слияние веток от текущего положения указателя до самого последнего(ему дается имя ORIG_HEAD)

//======================= Удаленный репозиторий ==========================

sudo git clone https://github.com/inohodec/OOP-patterns             //клонируем репозиторий в текущую папку,в текущей папке создасться новая 
                                                                    //с именем репозитория OOP-patterns
sudo git clone https://github.com/inohodec/OOP-patterns .           //то же, что и выше, но копирует файлы в текущую папку без создания папки OOP-patterns

sudo git remote add my-repo https://github.com/inohodec/TEST        //Должен быть создан заранее на сайте ginhub или bitbucket
git remote -v                                                       //Просмотр списка удаленных репозиториев
sudo git remote remove my-repo https://github.com/inohodec/TEST     //Удаляет удаленный репозитоий
git branch -va                                                      //v-verbose подробный, a-all отобразить все репозитории 
git push my-repo master
git push origin

//======================= Отслеживание ===========================
git pull --rebase                                                   // обычный git pull может приводить к созданию ненужных merge-коммитов, ухудшающих историю изменений. 
Если, находясь на отслеживаемой ветке, вы наберёте git pull, Git уже будет знать, с какого сервера получить
все удалённые ссылки и сделает слияние с соответствующей удалённой веткой. Т.е. после git clone в ветке master можно делать не
"git push master origin/master" , а просто "git push" и т.д.

Важно отметить, что когда при получении данных "git fetch" у вас появляются новые удалённые ветки, вы не получаете автоматически 
для них локальных редактируемых копий, как в случае с git clone, которая создает указатель и непосредственно локальную ветку master
и сливает в нее наш origin/master и в дальнейшем ссылается на него. Другими словами, в нашем случае вы не получите новую ветку 
serverfix,а только указатель origin/serverfix, который вы не можете менять. Чтобы слить эти наработки в свою ТЕКУЩУЮ  рабочую ветку, 
выполните "git merge origin/serverfix". Если вам нужна своя собственная ветка serverfix, над которой вы сможете
работать, то вы можете создать её на основе удалённой ветки: 

git checkout --track origin/serverfix                   //создает ветку serverfix и связывает с удаленной origin/serverfix для отслеживания
git checkout -b anyname origin/serverfix                //создает ветку anyname и связывает с удаленной для отслеживания

Если я поделюсь веткой на сервере: git push origin new_branch, то ветка сольётся туда но не станоет отслеживаемой!!!
Нужно выполнить 
git branch -u origin/new_branch                                     //для того что бы связать текущую (ceotcnde.oe. new_branch) с 
                                                                      удаленной веткой origin/new_branch

Команда "git fetch" загрузит с сервера все изменения, которых у вас еще нет, но пока не будет изменять вашу рабочую директорию. 
Эта команда просто получает данные для вас и позволяет вам самостоятельно сделать слияние. Тем не менее, существует команда под
названием "git pull", которая является по существу командой "git fetch", непосредственно за которой следует команда "git merge", 
в большинстве случаев. Если у вас есть отслеживаемая ветка, либо она явно установлена или она содержится вследствие создания вами 
командами "clone" или "checkout", "git pull" увидит, что сервер и ветка вашей текущей ветки отслеживается, извлечет с сервера и затем 
попытается объединить в удаленную ветку.
Обычно лучше просто явно использовать команды fetch и merge, поскольку магия git pull может часто сбивать с толку.
                         



/******************* An Example with Remote Repository ----------------------
1 переходим в папку с проэктом
2 git init              //создаем репозиторий гита
2 git add .
3 git commit -m "My first Commit"
4 sudo git remote add my-remote-repositiry https://inohodec@bitbucket.org/inohodec/test.git  //Добавили удаленный репозиторий для работы
5 git remote -v         //Проверяем добавился ли репозиторий 
6 git push my-remote-repositiry master      //отправляем ветку в удаленный репозиторий
7 git branch -va        //проверяем в git check  
8 sudo git clone https://inohodec@bitbucket.org/inohodec/test.git .  //другой пользователь клонирует репозиторий себе на 
  локальный комп
9 Пользователь создал новую ветку под свою задачу и переключился на нее - git checkout -b new_branch
10 Далее ользователь выполнил свою задачу, добавил новый файл в контроль версий "git add parser.php", и сделал коммит 
   git commit -m "Finished parser"

11.1 вариант 1 слить ветку в удаленный репозиторий и сеньйор сделает все сам - git push origin parser(хоть мы и называли 
     удаленный репо как test-repo, при    клонировании его имя сменилось на origin). На этом все
11.2 вариант 2 смерджить две ветки в одну и залить на уд.репозиторий для того, чтобы синьйор скачал код оттуда себе в лок комп.
    git checkout master     //переходим в ветку мастер
    git merge parser        //сливаем две ветки в одну
    git branch -v           //проверяем что бы коммиты у веток стали одинаковыми
    git push origin master  //отправляем в master в удаленный репозиторий
    git branch -va          //проверяем что-бы все коммиты у репозиториев совпадали

12 Синьор теперь должен скачать изменения себе(2 способа).
12.1 
    git fetch test-repo                           //скачивает и обновляет все локальные копии удаленного репозитория, ВАЖНО понимать, 
                                                    что локальная ветка master старая
    git branch -va                                //сверяем версии локального репа и копии удал. репа убеждаясь что они разные
    git checkout my-remote-repositiry/master      //переходим в ветку копии удаленного репа и проверяем изменения и если все ок, 
                                                    то мерджим их 
    git checkout master
    git merge my-remote-repositiry/master
    git branch -va          //Убеждаемся что версии одинаковые
12.2
    git pull test-repo master     //качает ветку мастер из удаленного репа и сливает с текущей
    
//----------------------СТОЛКНУЛСЯ С ОШИБКОЙ---------------------


Я получил эту ошибку, когда сначала настроил локальный репозиторий. Затем отправился в github и создал новый репозиторий. 
Затем я запустил

git remote add origin <repository url>

Когда я попытался нажать/вытащить, я получил ту же ошибку fatal: unrelated_histories. Вот как я его исправил:

git pull origin master --allow-unrelated-histories
git merge origin origin/master
... add and commit here...
git push origin master

//-------------------- .gitignore -------------------------
Git позволяет гибко настраивать игнорирование определенных файлов и директорий. Делается это с помощью файла .gitignore:

# В этом файле можно оставлять комментарии
# Каждая строчка — это шаблон, по которому происходит игнорирование

# Игнорируется файл в любой директории проекта
.DS_Store

# Игнорируется директория в любой директории проекта
node_modules

# Игнорируется директория в корне git-репозитория
/coverage

# Игнорируются все файлы с расширением sqlite3 в директории db,
# но не игнорируются такие же файлы внутри любого вложенного каталога в db
# например, /db/something/lala.sqlite3
/db/*.sqlite3

# игнорировать все .txt файлы в каталоге doc/
# на всех уровнях вложенности
doc/**/*.txt
Как только в проект добавляется файл .gitignore, то он сразу начинает работать. Все новые файлы, попадающие под игнорирование, не отобразятся в выводе команды git status.

Иногда бывает такое, что программист случайно уже добавил в репозиторий файл, который нужно проигнорировать. В этой ситуации недостаточно обновить правила игнорирования. Дополнительно придется удалить файл или директорию из git с помощью git rm и закоммитить.
















