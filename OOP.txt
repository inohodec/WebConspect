--------------================== ПАТТЕРНЫ ПРОЭКТИРОВАНИЯ =======================------------------

ВСЕ паттерны обеспечивают возможность изменения некоторой(какой-либо) части системы независимо от других частей

                                ПРИНЦИПЫ ПРОЭКТИРОВАНИЯ

1 Всегда выделяй переменные составляющие приложения и инкапсулируй их, чтобы позднее их можно было изменять или расширять без воздействия на постоянные составляющие(отличный пример паттерн Strategy: инкапсуляция полета и крякания уток из книги ПП).
   
  В ОО-системах классы обычно представляют сущности, которые обычно обладают как состоянием(переменные экземпляров класса), так и методами(поведением екземпляров так сказать). Однако даже поведение может обладать состоянием и методами; к примеру поведение полета насекомого или птицы может использовать переменные экземпляров, представляющие атрибуты полета(кол-во взмахов  
  крыльев за единицу времени, максимальная высота полета, скорость и т.д.)                                                       
----------------------------------------------------------------------------------------------------------------------------------

2 Программируй на уровне интерфейсов(абстрактный класс или интерфейс)
----------------------------------------------------------------------------------------------------------------------------------

3 Отдавай предпочтение композиции, а не наследованию. 
  Системы созданные по этому принципу облядают бОльшей гибкостью, чем системы 
  созданные по принципу наследования. Они позволяют не только инкапсулировать свойства алгоритмов, но и изменять их поведение во время выполнения - при условии, что подключенный посредством композиции компонент, реализует "правильный" интерфейс.
----------------------------------------------------------------------------------------------------------------------------------

4 Нужно стремиться к слабой связанности взаимодействующих объектов
  
  Если два объекта могут взаимодействовать, не обладая при этом практически никакой информацией друг о друге, такие объекты     
  называются слабосвязанными.                                                                                                   

  В контексте паттерна "Наблюдатель" это значит:
    
    1) Единственное что знает субъект о наблюдателе - то, что наблюдатель реализует некоторый интерфейс (Observer)

    2) Новые наблюдатели могут добавляться в любой момент, мы можем заменить один наблюдатель другим или же удалить его совсем. По сути можно провести параллель и со "Стратегией", в которой метод setNewBehaviour(Flyable $fly) может менять одно поведение на другое, главное чтобы новый элемент реализовывал правильный интерфейс.

    3) Добавление новых типов наблюдателей не требует модификации субъекта, главное что новый наблюдатель реализует нужный интерфейс.

    4) Субъекты наблюдателя могут быть использованы независимо друг от друга для других целей.

    5) изменения в субъекте или наблюдателе не влияют на друую сторону.
----------------------------------------------------------------------------------------------------------------------------------

5 Классы должны быть открытыми для расширения, но закрытыми для изменения.

  Суть в том, чтобы классы можно было легко расширять новым поведением без изменения существующего кода. Это даст нам архитектуру, устойчивую к изменениям и достаточно гибкую для поддержки новой функциональности в соответствии с изменившимися требованиями.

  Следование принципу откытости/закрытости обычно приводит к появлению новых уровней абстракции, что усложняет код. Поэтому лучше сосредоточится на тех областях архитектуры, которые с наибольшей вероятностью будут изменяться, и применять их там.
-----------------------------------------------------------------------------------------------------------------------------------

6 Принцип инверсии зависимостей: код должен зависить от абстракций, а не от конкретных классов

  Это значит, что "высокоуровневые" компоненты не зависят от низкоуровневых, вместо этого и те и другие должны зависеть от абстракций (Фабричный метод: класс PizzaStore и виды создаваемых фабричным методом пиц зависят от интерфейса Pizza)

  РЕКОМЕНДАЦИИ:
    1. Сыылки на конкретные классы не должны храниться в переменных(при использовании "new" сохраняется ссылка на конкретный класс. Используем фабрику!)

    2. В архитектуре не долно быть классов, производных от других классов. (Наследование от конкретного класса создает зависимость от него. Определяй классы производные от абстракции - интерфейсов и абстрактных классов)
    
    3. Методы не должны переопределять методы, реализованные в каких-либо из его базовых классов(Если методы переопределяются, значит класс был плохой абстракцией. Методы реализованные в базовом классе должны использоваттся всеми субклассами)

    !!! Рекомендации - это ориентир которого нужно придерживаться, а не "железное правило", но нужно стараться нарушать их как-можно реже и нарушая, на то должны быть причины. Понятно что следовать им на 100% нереально, но и нужно всегда о них помнить...
------------------------------------------------------------------------------------------------------------------------------------

7 Принцип минимальной информированности: общайтесь только с близкими друзьями(фасад)

  Это значит что при проэктировании системы для любого объекта следует обратить внимание на количество классов с которыми он взаимодействует и каким способом это взаимодействие организовано.
  Этот принцип препятствует созданию архитектур с большим количеством тесносвязанных классов в которых изменение в одной части системы каскадно распространится на другие части. Что приводит к потере гибкости системы, усложняет её понимание и удорожает её поддержку.

  Возьмем произвольный объект; согласно принципу, ИЗ ЛЮБОГО МЕТОДА ЭТОГО ОБЪЕКТА ДОЛЖНЫ ВЫЗЫВАТЬСЯ ТОЛЬКО МЕТОДЫ ПРИНАДЛЕЖАЩИЕ:

  - самому объекту                             | первые три правила запрещают
  - объектам, переданным в параметрах метода   | вызывать методы для объектов,
  - любому объекту созданному внутри метода    | полученных в результате вызова других методов

  - любым компонентам объекта                  | под компонентом понимается любой объект на кот. ссылается
                                               | переменная экземпляра, т.е. речь идет об объекте, связанном отношением
                                               | типа "содержит"
                                    ПРИМЕР:
  без принципа

    public getTemp()
    {
      $thermometer = $this->station->getTermometer();       //получаем объект thermometer
      return $thermometer->getTemp();                       //вызываем метод самомтоятельно
    }


  с принципом

    public getTemp()
    {
      $return $this->station->getTemp();       //в классе объекта $this->station есть метод который обращается к 
    }                                          // thermometer за нас. Тем самым сокращая кол-во классов от которых зависит код
-----------------------------------------------------------------------------------------------------------------------------------

8 Голливудский принцип - Не вызывайте нас, мы вас сами вызовем.
  В контексте Шаблонного метода:
  Помогает предотвратить "разложение зависимостей" - явление при котором компоненты высокого уровня зависят от компонентов низкого, 
  которые тоже зависят от ... и т.д.
  Этот принцип позволяет компонентам низкого уровня подключаться к системе, но компоненты высокого уровня сами решают, когда и 
  как те должны использоваться. Иными словами высокоуровневые компоненты запрещают низкоуровневым "проявлять инициативу". 
  Т.е. субклассы "шаблонного метода" никогда не обращаются к абстрактному классу пока он не обратится к ним.

  разниза между Голливудским принципом и Инверсией зависимости:

    Инверсия зависимостей учит нас избегать использования конкретных классов и по возможности работать с абстракциями. Голливудский
    принцип напрвлен на построение инфраструктур и компонентов, в которых компоненты низкого уровня могут учавствовать в 
    вычислениях без формирования зависимостей между компонентами низкого и высокого уровней. По сути оба принципа обеспечивают 
    логическую изоляцию, но принцип инверсии зависимостей является более сильным и общим утверждение, относительно того как избегать 
    зависимостей в архитектуре.
------------------------------------------------------------------------------------------------------------------------------------

9 Класс должен иметь только одну причину для изменения.
  Каждая обязанность класса является областью потенциальных изменений. Несколько обязанностей - несколько причин для изменения.
  Принцип указывает на то, что у класса должна быть только одна обязанность.
  В реальной жизни все немного сложнее: разделение обязанностей в архитектуре является одной из сложнейших задач. Наш мозг склонен 
  объединять аспекты поведения даже в том случае, если в действительности речь идет о двух разных обязанностях. Единственый путь к её 
  решению - анализ архитектуры и отслеживание возможных причин изменений классов в ходе роста системы.

  СВЯЗНОСТЬ - термин часто используемый для оценки логического единства функций класса или модуля.
    Мы говорим, что модуль или класс обладает "высокой" связностью, если он спроектирован для выполнения группы взаимосвязанных функций. Классы с "низкой" связностью проэктируются на основе разрозненых функций.
    Концепция связности является более общей, чем принцип одной обязанности, но эти два понятия тесно связаны. Классы, соответствующие принципу, обычно обладают "высокой" связанностью и более просты в сопровождении, чем классы с многими обязанностями и низкой связанностью.
