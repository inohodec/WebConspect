<?php 
#====================================РЕГУЛЯРНЫЕ ВЫРАЖЕНИЯ================================
/*
Нужно в простых задачах использовать str_replace и т.д., т.к. они ЗНАЧИТЕЛЬНО быстрее регулярных выражений, кои по сути "насилуют компьютер".

Важная инфа
1. Всегда заключать выражение в апострофы, т.к. символ $ в двойных кавычках значит переменную, а не спец символ в паттерне

2. Необходимо всегда заключать выражение в кавычках в ограничители, ими могут быть любые символы, к примеру '/.../' или '*...*', также следует помнить если разделитель присутствует в паттерне, то его нужно экранировать символом \ '/$+\/.+/', но это не касаеться [], '[$+[ab||ba].+]' поэтому он самый удобный

3. Обратный слеш "/". Все сложно, т.к паттерн для сравнения принимаеться в php как строка и запись вида 
'[\/path/file]' возможна, но нежелательна ведь \ требует удвоения для правильного отображения. Правильно будет '/\\/path\\/file/' - это выражение преобразуется  в строку \/path\/file, т.е. \ экранирует сначала сам себя, а потом полученная строка передается в сравнение и уже один получившийся символ экранирует / и он считаеться слешем, а не ограничителем.
примеры:
'[\\\\path]' = \path, т.е. сначала паттерн преобразуеться в строку и 4 слэша превращаються в 2 \\path, далее наш паттерн начинает участвовать в сравнении и 1вый "\" экранирует второй "\" превращая его в обычный символ

'[\\S+\\\\\\S+]' = (\S+) - любой непробельный символ + (\\) просто символ обр. слеша + (\S+) или что-то типа (\S+)(\\)(\S+), в итоге получаем что-то типа "любоеИмя\любоеИмя" т.е. ищет к примеру любое имя каталога после которого идет любое имя файла или если усложнить '[\\S+\\\\\\S+\\.txt]' любой каталог + любой txt файл

также для наглядности можно просмотреть реальный паттерн который будет использоваться функцией выведя  выражение через htmlspecialchars, так что '[\\S+\\\\\\S+\\.txt]' будет в реале искать [\S+\\\S+\.txt]

*/
$srt = "/etc\\/bin\\/program.bin";
$result = preg_match('/\\/.+\\/.+/', $str);

//==============Классы Символов=======================
"."- любой символ
\s - пробельный символ " ", "\t", "\n", "\r" 
\S - любой символ кроме пробельного
\w - любая буква или цифра
\W - не буква и не цифра
\d - цифра от 0 до 9
\D - все, что угодно но не цифра

#-----------Дополнительные выражения для символов

[:alpha:] - буква
[:digit:] - цифра
[:alnum:] - буква или цифра
[:space:] - пробельный
[:lower:] - нижний регистр
[:upper:] - верхний регистр
[:punct:] - знак пунктуации

'/myfile[:digit:]/' // ищет имя myfile в конце которого 1 цифра "myfile2, myfile9"
'/abc[[:digit:]]+/' // ищет имя myfile в конце которого 1 или более цифр "abc27, abc96"
'/f_[[:alpha:][:digit:]]/'//ищет f_+любой символ+любая цифра f_k3

$str = 'as567.546';
echo preg_match ('/as[[:digit:]]+[[:punct:]][[:digit:]]+/', $str, $arr);//as567.546
echo preg_match ('/as[[:digit:]]+[[:punct:][:digit:]]/', $str, $arr);//as567.5

//ВАЖНО ЧТО  ВНУТРИ КВАДРАНТЫХ СКОБОК ТОЧКА СТАНОВИТСЯ ПРОСТО ТОЧКОЙ

echo preg_match ('/as[[:digit:].]+[[:digit:]]+/', $str, $arr);//as567.546

//------------Отрицательные классы---------------------

'/file_[^MAX]+/' //выберет все имена file_ после которых идут любые символы кроме M, A, X. file_X = false 

//-----------Повторения------------------------
* - любой символ 0 и более раз
+ - любой символ 1 и более раз
? - любой символ 0 или 1 совпадение

$str = 'hello';
echo preg_match ('/hell?o/', $str, $arr);// найдет совпадение в строке hello и helo

X{2} - Повторяеться 2 раза
X{2,5} - Повторяеться от 2-х до 5-ти раз
X{2,} - 2 и более раза
//ВАЖНО в скобках не должно быть пробелов по типу {2, 5} и т.п.
echo preg_match ('/hel{2}o/', $str, $arr);// найдет совпадение в строке hello
echo preg_match ('/hel{0,2}o/', $str, $arr);// найдет совпадение в строке hello и helo и heo


//---------Мнимые символы---------------------

^  - начало строки
$  - конец строки
\b - начало или конец слова
\B - любая позиция кроме начала или конца слова

'/^\\w:/' - "*:" в начале строки
'/\\w+\\.txt$/' - "*.txt" в конце строки


//--------Альтернатива и группировка-------------------
//ВАЖНО перед и после | не должно быть пробелов по типу as | sa,  правильно as|sa.
'/\\w{1,10}\\.jpg$|\\w{1,10}\\.png$/' //все что кончаеться на jpg или png
'/(\\w{1,10}\\.jpg|\\w{1,10}\\.png)$/' //тоже что и выше

'/hel(p|l)/' //верно и для help и hell
'(hell|help)$' //заканчиваеться либо на hell либо на help


//---------------Карманы---------------------------------
$string = "15-10-1954";
preg_match("/(\\d{2})-(\\d{2})-(\\d{4})/i", $string, $matches) or die("there aren't any matches");
foreach ($matches as $match) {
    echo $match."<br>";
}
//в скобках находятся так называемые "карманы", сначала preg_match ищет полное совпадение созданного нами паттерна("2-цифры"-"2-цифры"-"4-цифры"), далее создается массив $matches, в 0 индексе хранится найденная строка целиком -"15-10-1954", первая скобка - 1карман, вторая - 2ой и т.д. То есть это как-бы подстроки содержащиеся в найденной строке и начиная с индекса 1 $matches хранит значения наших карманов
/*
Array
(
    [0] => 15-10-1954
    [1] => 15
    [2] => 10
    [3] => 1954
)

*/
//Допустимы символы а-я, a-z независимо от регистра, также цифры и "!" "." "," "-" "/" "\" """ "'"
echo preg_match('/^[а-яёa-z0-9-_,\\.\\-!\'"/\\\\[:space:]]+$/iu', 'Привет чувак Windows10 Foreva! Zx. Fghj!!');    //Вывод 1


preg_match("/(?<day>\\d{2})-(?<month>\\d{2})-(?<year>\\d{4})/i", $string, $matches);
echo "{$matches[day]} - {$matches[month]} - {$matches[year]}";
//то же что и выше но мы создаем ассоциативный массив $matches с ключами ['day'],['month'],['year']
//Для етого есть 2 способа: (?<KEY_NAME>PATTERN), (?'KEY_NAME'PATTERN)

$data = preg_replace("/(\d{2})-(\d{2})-(\d{4})/", "YEAR: $3, MONTH $2, DAY: \\1", $string);
echo "<br>$data<br>";
//Если строка найдена, то нашим карманам присваиваются переменные $1, $2 и т.д или \\1, \\2 и т.д. В строке замены мы указываем переменные в любой последовательности строка "15-10-1954" меняется на YEAR: 1954, DAY: 15, MONTH 10

$text = htmlspecialchars(file_get_contents(__FILE__));
$html = preg_replace('/(\$[a-z]\w*)|(__FILE__)/is' , '<b>$1<span style="color: burlywood">$2</span></b>', $text);
echo "<pre>$html</pre>";
//данный код берет содержимое текущего файла и добавляет жирность каждой переменной($name) и цвет каждому 
//слову __FILE__
//Пример содержимого файла: <p>Массив $matches содержит имена __FILE__</p>


//---------------Модификаторы-----------------------------
'/.../i' - игнорирование регистра 
'/.../x' - пропуск пробельных символов и комментариев
'/.../s' - однострочный поиск
'/.../m' - многострочность
'/.../e' - выполнение программы при замене 399ст
'/.../u' - включает UTF8 режим, обязателен для работы с кириллицей

//---------------Функции-----------------------------------
preg_match(pattern, subject, matches);
preg_match_all(pattern, subject, matches);

preg_replace(pattern, replacement, subject); //по умолчанию работает в 1 строчном режиме
//работают с карманами, подробно не разбирал
preg_replace_callback(pattern, callback, subject);
preg_replace_callback_array(patterns_and_callbacks, subject)

/* ссылки
http://ru.php.net/manual/ru/ref.pcre.php
http://www.bitcetera.com/page_attachments/0000/0030/regex_in_a_nutshell.pdf
/*


