<?php 
//----------------------Абстрактные классы----------------------------
//
/*
Используються как шаблон(типа интерфейса) для классов которые его расширяют(наследуют), НЕВОЗМОЖНО создать
экземпляр(объект) этого класса. Так же может содержит, абстрактные методы, которые должны быть ОБЯЗАТЕЛЬНО реализованы в классах которые его расширяют(носят описательный характер), причем таким же образом(с той же сигнатурой) что и в абстрактном классе или же должны быть объявлены абстрактными. Также может содержать обычные методы передающиеся по наследству.
Абстрактные методы объявляются как функции с предварением abstract только заканчиваются не телом {}, а точкой с запятой. \
Если класс содержит хоть один абстрактный метод, он должен быть объявлен как абстрактный!!!
НАСЛЕДНИК МОЖЕТ ИМЕТЬ ТОЛЬКО 1го РОДИТЕЛЯ
*/

abstract class Item {
	public $price;
	function setPrice($val) {

	}
	abstract function $totalPrice (array $offer);
}

class ItemCD extends Item
{
	// Если не создать данный метод $totalPrice($offer), причем обязательно с 1им аргументом array, будет ошибка
	function $totalPrice(array $offer) { 
		echo ($this->price - $offer)
	}
}

/*
Создавая абстрактный метод, мы гарантируем, что его реализация будет до­ступной во всех конкретных 
дочерних классах, но детали этой реализации остаются за нами.


//************************Интерфейсы-------------------------------------
/*
По сути шаблон содержащий методы для реализации в наследуемых классах(не может содержать св-ва), все методы в нем считаются абстрактными(носят описательный характер) и обязательны для реализации в дочерних классах(если они конечно тоже не абстрактные).
Все методы должны быть public
НАСЛЕДНИК МОЖЕТ РЕАЛИЗОВЫВАТЬ МЕТОДЫ НЕСКОЛЬКИХ ИНТЕРФЕЙСОВ
*/
interface Item {
	function getPrice();
	function setPrice(int $price);
}

interface Offer {
	function setOffer(int $val);
}
//используем оба интерфейса
class ItemCD implements Item, Offer {
	function getPrice() {
		//code...
	}
	function setPrice(int $price) {
		//code...
	}
	function setOffer(int $val) {
		//code...
	}
}
//Либо можно вот так наследовать
interface Type {
    public function info($val);
}
interface Color extends Type {//наследуем Type
    public function color($val);
}
interface Features extends Color {//наследуем Type и Color
    public function price($val);
}
class Car implements Features {//наследуем Type, Color и Features
    function info($val)  {    }
    function color($val) {    }
    function price($val) {    }
}