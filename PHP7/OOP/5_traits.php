<?php
//-------------------------------Трейты----------------------------------
/*
Трейты - это своего рода примеси, как в SCSS.

По сути, трейты напоминают классы, для которых нельзя создать экземпляр объекта, 
но которые можно включить в другие классы. Поэтому любое свойство (или метод) определенное в трейте, становится частью того класса, в который этот трейт включен. При этом трейт изменяет структуру этого класса, но не меняет его тип.
Можно считать трейты своего рода оператором include, действие которого распро­страняется только на конкретный класс.
*/
trait Tax {
	private $ndsRate = 20;
}
trait RetTax {
	private $retirementTax = 15;
}

Class Delivery {
	use Tax, RetTax;
}

//---- Важно!!!------
/*
Если класс наследует св-ва или методы от абсрактного класса или интерфейса, то он меняет свой тип и начинает относится к ним же, а вот трейт не меняет пренадлежность класса:
*/
abstract class Payment {
	abstract function pay();
}
interface Tax {
	function setTax();
}
trait Postal {
	privat $postPrice = 25;
}
//используем абстрактный класс, интерфейс и трейт для расширения класса
class Delivery extends Payment implements Tax {
	use Postal;
}
$item = new Delivery();// Данный класс относится к Delivery, Payment и Tax, но не к Postal

//Во всех 3х случаях код выполнится т.к. объект относится ко всем классам которые он наследует
a($item);
b($item);
c($item);
//выведет ошибку т.к. исползование трейтов меняет структуру класса(добавляет методы и св-ва) но не его тип 
d($item); //ERROR , т.к. такого типа как Postal нет(т.к. трейты не меняют тип класса)


function a(Payment $obj) {/*some code*/}
function b(Tax $obj) {/*some code*/}
function c(Delivery $obj) {/*some code*/}
function d(Postal $obj) {/*some code*/} 

//Если трейт используется в нескольких классах одновременно, то у нас не будет обхего типа, который можно было-бы использовать в уточнениях для сигнатур методов. Но мы можем использовать его вместе с интерфейсом для решения данной проблемы


//Вспомоготельный интерфейс для изменения типа класса(создания общего типа для нескольких классов)
interface Tax {
	public function generateTax(); 
}
//трейт который будет в нескольких классах(он не меняет тип данных)
trait CommonTax {
	function generateTax() { 
		return $price - $nds;
	}
}
//класс который использует трейт и наследует интерфейс
class Item implements Tax {
	use CommonTax;
	//some code...
}
class Delivery implements Tax {
	use CommonTax;
	//some code...
}
//some code
function calcItem(Tax $obj1, Tax $obj2) {
	//do thomething with $obj1 and $obj2...
}
$thing = new Item();
$supply = new Delivery();
calcItem($thing, $supply);

//Мы создали 2 класса в который "Внедрили" код из трейта и для того, что бы можно было контролировать тип данных, мы создали интерфейс который обязывает включать в класс метод generateTax() - что мы и сделали с помощью трейта и ктому же блягодаря интерфейсу изменившему тип класса мы можем контролировать тип данных в дальнейшем

//--------------------------Конфликт имен------------------------------
/*
При большом кол-ве трейтов, возможна ситуация, когда внутри разный трейтов могут появится несколько методов с одинаковыми именами. В данном случае будет ошибка, но её можно предотвратить используя ключерое слово insteadof
*/

trait Tax {
	function getPrice () {
		return $a - $b;
	}
}
trait Delivery {
	function getPrice () {
		return 35 + $a;
	}
}
//выше мы определили 2 одинаковых метода getPrice ()
class Price {
	use Tax, Delivery {
		Tax::getPrice insteadof Delivery; //Указали какой из них использовать
		//если нужен доступ ко второму методу, то указываем псевдоним иначе пропускаем
		Delivery::getPrice as deliveryPrice;
	}

}

//------------------Трейты и статические методы-------------------------
trait Price {
    private static $val = 15;
    static function getPrice($price) {
        return $price * self::$val;
    }
}
class Delivery {
    use Price;
}
echo Delivery::getPrice (200);

//------------------Доступ к св-вам базового класса--------------------
trait Mixin {
    public function calc()
    {
        return $this->val * 10;
    }
}
class ClassName {
    private $val = 20;
    use Mixin;
}
class Price {
	use
}
$item = new ClassName();
echo $item->calc();
/*
проблема состоит в том что метод из трейта обращается к св-ву базового класса, но если данный трейт применить к примеру к нескольким классам, то некоторые из них могут не содержать данное св-во. Поэтому это не лучший способ реализации!!!
Трейты так же поддерживают абстрактные методы!!!
*/
trait Price {
    abstract function calcPrice();
    public function getPrice()
    {
        echo $this->calcPrice();
    }
}
class TotalPrice {
    use Price;
    function calcPrice() { return 1000; }//если не объявлена то будет ошибка
}
$new = new TotalPrice;
$new->getPrice();

//-------------------------------------Изменение прав доступа-----------------------------

/* возможно поменять права достапа св-в и методов трейта внутри класса, метод похож на тот,
который мы использовали в решении конфликтов имен методов. Важно помнить что способ не меняем сам трейт, он меняет лишь значение внутри классов и если у нас 2 класса которые используют трейт и в одном из них мы меняем права доступа, то другой останеться без изменений, т.к. сам трейт не меняется.
*/
trait Top
{
    protected function oo()
    {
        echo "Hello";
    }
}

class Bottom
{
    use Top {
        Top::foo as public;
    }
}
class Dno {
	use Top;
}

$new = new Bottom;
$new1 = new Dno;
$new->foo ();//ок - мы изменили доступ на public
$new1->foo ();//Ошибка т.к. foo() - privat
