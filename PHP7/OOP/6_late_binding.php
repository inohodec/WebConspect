<?php 
//-----------------Позднее статическое связывание------------------
/*
Рассмотрим пример "фабрики-объектов":
*/

abstract class Father {

}
//создаем подкласс с функцией create() которая возвращает экземпляр объекта Son
class Son extends Father
{
	public static function create() {  return new Son(); }
}
//создаем подкласс с функцией create() которая возвращает экземпляр объекта Daughter
class Daughter extends Father
{
	public static function create()	{  return new Son(); }
}

$obj_Of_Son = Son::create();//создали объект класса Son
$obj_Of_Daugh = Daughter::create();//создали объект класса Daughter

//В коде сверху есть один существенный недостаток, к примеру если у нас будет 100 подклассов Father, то придется в каждый подкласс добавлять метод create(), что не очень продуктивно. Ниже показан пример(неправильный) как можно добиться этого, на этом же примере мы и поймем, что такое позднее связывание.

abstract class Father {
	public static function create()
	{
		return new self();
	}
}
class Son extends Father{}

class Daughter extends Father{}

$obj_Of_Son = Son::create();//создали объект класса Father при условии что класс Father не абстрактный
$obj_Of_Daugh = Daughter::create();//...то же , что и obj_Of_Son(создался объект Father)

//к сожалению ключевое self не работает как $this для экземпляров класса, оно ссылается на метод класса в котором БЫЛо ОБЪЯВЛЕНо или ПЕРЕНАЗНАЧЕНО последниий раз! в данном случае мы получим ошибку попытки создания объекта абстрактного класса, но даже если мы объявим класс Father не абстрактным, а обычным, все равно создадуться 2 объекта класса Father. Для исправления данной ситуации нужно использовать ключевое слово "static::", которое будет ссылаться не на класс в котором был объявлем метод(содержащий класс), а на класс из КОТОРОГО ОН ВЫЗВАН(вызывающий класс)

//Важно понимать, что static() обращается именно ко всему классу вызвавшему данный метод и возмет его название для создания класса, а вот если бы мы обращались к методу или св-ву static::something, и этот метод или св-во было объявлено не в вызывающем классе, то поведение было бы немного другим(об этом ниже) 

abstract class Father {
	public function create()
	{
		return new static();            //static() - этот метод получает ссылку на ВЫЗВАВШИЙ его класс
	}
}
class Son extends Father{}

class Daughter extends Father{}

$obj_Of_Son = Son::create();            //создали объект класса Son
$obj_Of_Daugh = Daughter::create();     //создали объект класса Daughter

//еще пример (пример чисто абстрактныйб для понимания)

class A {
    public static function who() { echo __CLASS__; }
    public static function test() { self::who(); }
}

class B extends A {
    public static function who() { echo __CLASS__; }
}
class C extends B {
    public static function who() { echo __CLASS__; }
}

B::test();//from class: A
C::test();//from class: A
/*
	то есть метод test() использующий self:: обращаеться к классу в котором он был обявлен впервые или переопределен в последний раз, соответственно test() был определен в классе "А". После этого test()
	ищет метод who() в классе "A" и выполняет его, возвращая имя текущего класса("А")
	То есть в дочерних классах на самом деле содержится что-то типа:
*/
class B extends A {
    public static function who() { echo __CLASS__; }
    //ссылка на метод test() который находится "физически" в классе "А"(или унаследовано от "А")
}
class C extends B {
    public static function who() { echo __CLASS__; }
    //ссылка на метод test() который находится "физически" в классе "А"(или унаследовано от "В")
}
/*
	Вызывая B::test(); интерпретатор берет класс "В" ищет там метод test(), но находит лишь ссылку перенаправляющую на класс "А", где test(), был определен. Далее интерпретатор идет в класс "А", берет метод test() и выполняет используя who() из того же класса("А").

	Вызывая С::test(); интерпретатор берет класс "С" ищет там метод test(), но находит лишь ссылку перенаправляющую на класс "А", где test(), был определен. Далее интерпретатор идет в класс "А", берет метод test() и выполняет используя who() из того же класса("А").

	Тот же вывод будет и в случае, если мы переопределим test():
*/
class A {
    public static function who() { echo __CLASS__; }
    public static function test() { self::who(); }
}
class B extends A { public static function test() { self::who(); } }
class C extends B { public static function test() { self::who(); } }
B::test();//from class: A
C::test();//from class: A
/*
	Вызывая B::test(); интерпретатор идет в вызваший метод test() класс "В" видит переопределенный метод test(), берет его и начинает выполнение who() из класса "В", но т.к. who() определена в классе "А", то в классе "В" находится лишь ссылка на класс "А" содержащий "реальный" who(), интерпретатор идет в класс "А", берет и выполняет метод  who() из контекста "А" печатая символ "А". 
	Вызывая С::test(); интерпретатор идет в вызваший метод test() класс "С" видит переопределенный метод test(), берет его и начинает выполнение who() из класса "С", но т.к. who() определена в классе "А" то в классе "С" находится лишь ссылка на класс "А", интерпретатор идет в класс "А", берет и выполняет метод  who() из контекста "А" печатая символ "А". 
	Идем дальше:
*/
class A {
    public static function who() { echo __CLASS__; }
    public static function test() { self::who(); }
}

class B extends A {
    public static function who() { echo __CLASS__;}
    public static function test() { self::who(); }
}
class C extends B {
    public static function who() { echo __CLASS__;}
    public static function test() { self::who(); }
}
B::test();//from class: B
C::test();//from class: C
/*
	Теперь оба метода test() и who() переопределены в каждом подклассе и присутствуют не ссылкой на "А", а "физически". Поэтому они выполняются "изнутри" класса "В" и "С". Но есть 2 нюанса:
	1. методы test() и who() в суперклассе "А" по сути теперь не нужны, т.к. они переопределены в подклассах
	2. Так же мы вернулись к тому с чего начинали и каждый подкласс содержит test() и who(), т.е. код дублируется
	Выход:
	*/
class A {
    public static function who() { echo __CLASS__; }
    public static function test() { static::who(); }
}
class B extends A {public static function who() { echo __CLASS__; }}
class C extends B {public static function who() { echo __CLASS__; }}
B::test();      //from class: B
C::test();      //from class: C
/*	
	Вызывая B::test(); интерпретатор идет в вызваший метод test() класс "В", находит там ссылку на метод  test() определенный в классе "А", идет и выполняет его. Главное отличие, static:: от self:: - это, то что ключевое слово static::	берет имя класса откуда был произведен вызов и начинает поиск метода who() с класса вызвавшего функцию test() в которой она содержится. Т.к метод who() переопределен в обоих дочерних классах, то выполнение метода происходит из их контекста.

	Иными словами static:: просто запоминает имя класса из которого был вызов и использует его для старта поиска методов и св-тв.

	Пимер немного бредовый и опять же получается, что метод who() в классе "А" дублируется и ненужен и правильнее было-бы так:
*/
class A {
    public static function test() { static::who(); }
}
class B extends A {public static function who() { echo __CLASS__; }}
class C extends B {public static function who() { echo __CLASS__; }}

/*
	ВАЖНО!!!!!!!!!!!!!!
		Надо понимать, что если поиск who() к примеру начат с класса "С" и данный метод не переопределен(т.е. в нем ссылка на класс "А"), то интерпретатор проследует по этой ссылке в класс "А" и запустит метод из контекста класса "А"
*/
class A {
    public static function test() { static::who(); }
    public static function who() { echo __CLASS__; }
}
class B extends A {}
class C extends B {}
B::test ();//A
C::test ();//A
/*
	Вызывая B::test(); интерпретатор идет в вызваший метод test() класс "В", находит там ссылку на метод  test() определенный в классе "А", интерпретатор идет в "А" и выполняет test(). static:: объявленный в классе "А" берет имя класса откуда был произведен вызов("В") и начинает поиск метода who() с класса вызвавшего функцию test()(класс "В"). Т.к метод who() не переопределен в дочернем классе "В" и в нем содержится ссылка на класс "А" содержащий "физический" метод, интерпретатор идет туда выполняет метод who() из контекста класса "А" и выводит А.
*/


//=============================ПЕРЕНАПРАВЛЕНИЕ ОТЛОЖЕНЫХ ВЫЗОВОВ==================================
class  Father {
    //метод foo() вызывает метод whoIs() из контекста класса от которого идет вызов
    static function foo() {
        static::whoIs();
    }
    static function whoIs() {
        echo __CLASS__."<br>";
    }
}
class Son extends Father {
    //создаем метод который вызывает другой метод foo() из суперкласса Father
    static function test()
    {
        Father::foo ();
        self::foo ();
        parent::foo ();
    }
    //переопределяем метод
    static function whoIs() {
        echo __CLASS__."<br>";
    }
}
class Grandson extends Son {
    //переопределяем метод
    static function whoIs() {
        echo __CLASS__."<br>";
    }
}

$call= new Grandson();//создаем экземпляр класса Grandson
$call->test();
/*
    результат:
Father
Grandson
Grandson
    $call->test(); - интерпретатор идет в класс объекта $call(Grandson), и ищет метод test(), соотв. он объявлен
    в класса Son и в классе Grandson содержится лишь ссылка на него, интерпретатор идет туда(в Son) и метод выполняется,
    далее интерпретатор выполняет метод Father::foo() который запускает метод whoIs() из класса Father, результат
    будет "Father". Вызов вида Father::foo() не перенаправляет(передает) значение места откуда был совершён и равнозначен
    варианту вызова из основного кода программы, а не изнутри класса, т.е. информации откуда пришел вызов 0 и
    static::whoIs() выполняется из места где он был определен(класс Father).

    self:: и parent:: в отличии от предыдущего случая перенаправляют вызов. Т.е. так как вызов test() был осуществлем из
    объекта $call класса Grandson эти ключевые слова передают(перенаправляют) значение места вызова ключевому слову static::,
    которое в свою очередь начинает поиск метода whoIs() с переданного ему self:: или parent:: значению класса откуда
    был произведен вызов(объект класса Grandson), который и выполняется (соотв. из контекста класса Grandson)
    выведя Grandson.
